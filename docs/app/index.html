<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#EDE9E8" />
    <title>Cycle Dashboard</title>
    <link
      rel="icon"
      type="image/png"
      sizes="96x96"
      href="./assets/icons/favicon-96x96.png"
    />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="./assets/icons/apple-touch-icon.png"
    />
    <link rel="manifest" href="./assets/icons/site.webmanifest" />
    <link rel="stylesheet" href="./style.css" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Instrument+Serif&display=swap"
    />
  </head>
  <body>
    <main class="dashboard">
      <header class="top">
        <span>Cycle</span>
        <div id="status" class="status" aria-live="polite" hidden>
          <div class="sk-three-bounce">
            <div class="sk-bounce"></div>
            <div class="sk-bounce"></div>
            <div class="sk-bounce"></div>
          </div>
          <span class="status-text" hidden>✔ Updated</span>
        </div>
        <span>Overlay</span>
      </header>

      <section class="center">
        <div class="cycle-day">
          <div class="cycle-number" id="cycleNumber">1</div>
          <div class="cycle-label">cycle day</div>
        </div>
        <div class="message">
          <h1 class="title" id="messageTitle" hidden></h1>
          <p class="description" id="messageDescription" hidden></p>
        </div>
        <button class="start-cycle" id="startCycleButton" type="button" hidden>
          Start new cycle
        </button>
        <p class="start-cycle-hint" id="startCycleHint" hidden></p>
      </section>

      <footer class="bottom">
        <div>
          <p class="date-label">Prev</p>
          <p id="prevDate">—</p>
        </div>
        <div>
          <p class="date-label">Next</p>
          <p id="nextDate">—</p>
        </div>
      </footer>
    </main>

    <script>
      const prevDateEl = document.getElementById("prevDate");
      const nextDateEl = document.getElementById("nextDate");
      const cycleNumberEl = document.getElementById("cycleNumber");
      const statusEl = document.getElementById("status");
      const statusTextEl = statusEl.querySelector(".status-text");
      const messageTitleEl = document.getElementById("messageTitle");
      const messageDescriptionEl = document.getElementById("messageDescription");
      const startCycleButtonEl = document.getElementById("startCycleButton");
      const startCycleHintEl = document.getElementById("startCycleHint");
      const params = new URLSearchParams(window.location.search);
      const tokenParam = (params.get("t") || "").trim();
      const apiBaseParam = (params.get("api") || "").trim();
      const defaultApiBase = "https://cycle-overlay-api.ksenia-ilinyh.workers.dev";
      const apiBase = (apiBaseParam || defaultApiBase).replace(/\/+$/, "");
      const pendingStartKey = "pendingStart";
      const updatingKey = "cycleOverlayUpdating";
      const pollIntervalMs = 5000;
      const pollTimeoutMs = 180000;
      const defaultCycleLength = 28;
      let currentCycleLength = defaultCycleLength;
      let currentPhase = "";
      let pendingStart = localStorage.getItem(pendingStartKey);
      let inPendingMode = Boolean(pendingStart && parseLocalISODate(pendingStart));

      function setStatus(mode, text) {
        if (!mode) {
          statusEl.hidden = true;
          statusTextEl.textContent = "";
          statusTextEl.hidden = true;
          statusEl.querySelector(".sk-three-bounce").hidden = true;
          return;
        }
        statusEl.hidden = false;
        const spinner = statusEl.querySelector(".sk-three-bounce");
        if (mode === "pending") {
          spinner.hidden = false;
          statusTextEl.hidden = true;
        } else {
          spinner.hidden = true;
          statusTextEl.hidden = false;
          statusTextEl.textContent = text || "";
        }
      }

      function parseLocalISODate(value) {
        const match = /^\d{4}-\d{2}-\d{2}$/.test(value);
        if (!match) return null;
        const [year, month, day] = value.split("-").map(Number);
        const date = new Date(year, month - 1, day, 12, 0, 0);
        return Number.isNaN(date.getTime()) ? null : date;
      }

      function formatDate(value) {
        if (!value) return "—";
        const date = parseLocalISODate(value) || new Date(value);
        if (Number.isNaN(date.getTime())) return "—";
        return date.toLocaleDateString("en-US", {
          month: "short",
          day: "2-digit",
          year: "numeric",
        });
      }

      function daysBetween(start, end) {
        const ms = end.getTime() - start.getTime();
        return Math.floor(ms / (24 * 60 * 60 * 1000));
      }

      function toLocalISODate(date) {
        const year = date.getFullYear();
        const month = `${date.getMonth() + 1}`.padStart(2, "0");
        const day = `${date.getDate()}`.padStart(2, "0");
        return `${year}-${month}-${day}`;
      }

      function showLocalOnlyHint(dateIso) {
        void dateIso;
        startCycleHintEl.textContent = "";
        startCycleHintEl.hidden = true;
      }

      function updateStartButton(cycleDay) {
        if (cycleDay >= 15) {
          startCycleButtonEl.hidden = false;
        } else {
          startCycleButtonEl.hidden = true;
        }
      }

      function normalizePhase(phase, phaseShort) {
        const raw =
          typeof phase === "string"
            ? phase
            : typeof phaseShort === "string"
              ? phaseShort
              : "";
        const value = raw.toLowerCase().trim();
        if (!value) return "";
        if (value.startsWith("lut")) return "luteal";
        if (value.startsWith("fol")) return "follicular";
        if (value.startsWith("men")) return "menstrual";
        if (value.startsWith("ovu")) return "ovulation";
        return value;
      }

      function render(startDateValue, cycleLengthValue, phaseValue) {
        const startDate = parseLocalISODate(startDateValue);
        if (!startDate) return;
        const today = new Date();
        const todayLocal = new Date(
          today.getFullYear(),
          today.getMonth(),
          today.getDate(),
          12,
          0,
          0
        );
        const cycleDay = Math.max(0, daysBetween(startDate, todayLocal) + 1);
        cycleNumberEl.textContent = String(cycleDay);
        updateCopy(cycleDay, phaseValue);
        updateStartButton(cycleDay);

        const prevDate = new Date(startDate);
        const nextDate = new Date(startDate);
        nextDate.setDate(nextDate.getDate() + cycleLengthValue);
        prevDateEl.textContent = formatDate(prevDate.toISOString().slice(0, 10));
        nextDateEl.textContent = formatDate(nextDate.toISOString().slice(0, 10));
        nextDateEl.classList.remove("updating");
      }

      function getCycleCopy(cycleDay, phase) {
        if (cycleDay === 1) {
          return {
            title: "Extra gentle",
            description:
              "Slower rhythm today. Gentle movement, warm tea, and a softer pace make a big difference.",
          };
        }
        if (cycleDay === 2) {
          return {
            title: "Feeling lighter",
            description:
              "The heaviness starts to fade. You might feel more like yourself again – still soft, but noticeably easier.",
          };
        }
        if (cycleDay === 3) {
          return {
            title: "Energy is coming back",
            description:
              "Momentum is quietly building. Your body feels stronger, clearer, and more ready to move forward.",
          };
        }
        if (cycleDay >= 4 && cycleDay <= 14 && (!phase || phase === "follicular")) {
          return {
            title: "Go mode",
            description:
              '"Let’s do it!" phase. Energy, focus, and confidence are rising – a great time to start, explore, and take action.',
          };
        }
        if (cycleDay >= 15) {
          return {
            title: "Slow down",
            description:
              "Energy gradually turns inward. Lower the pace, simplify plans, and give yourself a bit more care and space.",
          };
        }
        return null;
      }

      function updateCopy(cycleDay, phase) {
        const copy = getCycleCopy(cycleDay, phase);
        if (!copy) {
          messageTitleEl.hidden = true;
          messageDescriptionEl.hidden = true;
          messageTitleEl.textContent = "";
          messageDescriptionEl.textContent = "";
          return;
        }
        messageTitleEl.hidden = false;
        messageDescriptionEl.hidden = false;
        messageTitleEl.textContent = copy.title;
        messageDescriptionEl.textContent = copy.description;
      }

      function extractDataStart(data) {
        return data.lastPeriodStart || data.last_period_start || data.cycleStart || "";
      }

      function clearPendingState() {
        localStorage.removeItem(pendingStartKey);
        localStorage.removeItem(updatingKey);
        pendingStart = null;
        inPendingMode = false;
      }

      function setPendingState(startIso) {
        localStorage.setItem(updatingKey, "1");
        localStorage.setItem(pendingStartKey, startIso);
        pendingStart = startIso;
        inPendingMode = true;
      }

      async function fetchStatusData(cacheBust = false) {
        const dataPath = tokenParam
          ? `../data/users/${encodeURIComponent(tokenParam)}.json`
          : "./data.json";
        const requestUrl = new URL(dataPath, window.location.href);
        if (cacheBust) {
          requestUrl.searchParams.set("ts", Date.now().toString());
        }
        const response = await fetch(requestUrl.toString(), { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`Status load failed (${response.status})`);
        }
        return response.json();
      }

      function sleep(ms) {
        return new Promise((resolve) => {
          setTimeout(resolve, ms);
        });
      }

      async function waitForPublishedStart(targetStartIso) {
        const targetDate = parseLocalISODate(targetStartIso);
        if (!targetDate) {
          throw new Error("Invalid target start date");
        }

        const deadline = Date.now() + pollTimeoutMs;
        while (Date.now() < deadline) {
          const data = await fetchStatusData(true);
          const dataStart = extractDataStart(data);
          const dataStartDate = parseLocalISODate(dataStart);
          if (dataStartDate && dataStartDate.getTime() >= targetDate.getTime()) {
            return data;
          }
          await sleep(pollIntervalMs);
        }
        throw new Error("Timed out while waiting for calendar publish");
      }

      async function callStartCycle(dateIso) {
        if (!apiBase) {
          throw new Error("Missing worker endpoint. Add ?api=https://<worker-domain>");
        }
        if (!tokenParam) {
          throw new Error("Missing token. Add ?t=<token> to the dashboard URL.");
        }
        const requestUrl = new URL(`${apiBase}/start`);
        requestUrl.searchParams.set("date", dateIso);
        requestUrl.searchParams.set("t", tokenParam);
        const response = await fetch(requestUrl.toString(), {
          method: "POST",
          headers: {
            Accept: "application/json",
          },
        });
        if (!response.ok) {
          const text = await response.text();
          throw new Error(`Start request failed (${response.status}): ${text}`);
        }
        return response.json();
      }

      async function loadAndRender(cacheBust = false) {
        const data = await fetchStatusData(cacheBust);
        const dataStart = extractDataStart(data);
        const dataStartDate = parseLocalISODate(dataStart);
        const cycleLength =
          typeof data.cycleLength === "number" ? data.cycleLength : defaultCycleLength;
        const phaseValue = normalizePhase(data.phase, data.phase_short);
        currentCycleLength = cycleLength;
        currentPhase = phaseValue;

        if (inPendingMode && pendingStart) {
          const pendingDate = parseLocalISODate(pendingStart);
          if (pendingDate && dataStartDate && dataStartDate.getTime() >= pendingDate.getTime()) {
            clearPendingState();
            setStatus("complete", "✔ Updated");
          } else {
            setStatus("pending");
          }
        } else {
          setStatus(null);
        }

        const startToUse = inPendingMode && pendingStart ? pendingStart : dataStart;
        if (startToUse) {
          render(startToUse, cycleLength, phaseValue);
        }
      }

      startCycleButtonEl.addEventListener("click", async () => {
        if (startCycleButtonEl.disabled) return;
        startCycleButtonEl.disabled = true;
        const shouldStart = window.confirm("Start a new cycle today?");
        if (!shouldStart) {
          startCycleButtonEl.disabled = false;
          return;
        }
        const todayIso = toLocalISODate(new Date());
        setPendingState(todayIso);
        setStatus("pending");
        render(todayIso, currentCycleLength, currentPhase);
        showLocalOnlyHint(todayIso);
        try {
          await callStartCycle(todayIso);
          await waitForPublishedStart(todayIso);
          await loadAndRender(true);
        } catch (error) {
          clearPendingState();
          setStatus("complete", "Update failed");
          console.error(error);
        } finally {
          startCycleButtonEl.disabled = false;
        }
      });

      if (inPendingMode && pendingStart) {
        setStatus("pending");
        render(pendingStart, defaultCycleLength, "");
      }

      loadAndRender(true).catch((error) => {
        setStatus(null);
        clearPendingState();
        console.error(error);
        const cycleDayValue = Number(cycleNumberEl.textContent);
        if (!Number.isNaN(cycleDayValue)) {
          updateCopy(cycleDayValue, "");
          updateStartButton(cycleDayValue);
        }
      });

      const reloadParams = new URLSearchParams(window.location.search);
      if (reloadParams.get("reload") === "1") {
        reloadParams.delete("reload");
        reloadParams.delete("t");
        const nextUrl = `${window.location.pathname}${
          reloadParams.toString() ? `?${reloadParams}` : ""
        }`;
        setTimeout(() => {
          window.location.replace(nextUrl);
        }, 15000);
      }
    </script>
  </body>
</html>
